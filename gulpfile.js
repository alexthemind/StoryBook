var gulp, { src, dest, series, watch } = require('gulp')
var ts = require('gulp-typescript')
const minify = require('gulp-minify');
var tsProject = ts.createProject('tsconfig.json')
const merge = require('merge2')
const del = require('del')
const webpack = require('webpack')
var sftp = require('gulp-sftp');

function clean() {
    return del(['./dist/**','./definitions/**']);
}

function compile(){
    var tsResult = tsProject.src()
        .pipe(tsProject());
 
    return merge([
        tsResult.dts.pipe(gulp.dest('definitions')),
        tsResult.js.pipe(minify({
            ext:{
                min:'.js',
            },
            noSource: true,
            preserveComments: 'some'
        })).pipe(gulp.dest('dist'))
    ]);
}

exports.default = series(clean, compile);


const webpackDev = require('./webpack.dev.js')

function dev() {
    return new Promise((resolve, reject) => {
        webpack(webpackDev, (err, stats) => {
            if (err) {
                return reject(err)
            }
            if (stats.hasErrors()) {
                return reject(new Error(stats.compilation.errors.join('\n')))
            }
            resolve()
        })
    })
}

const buildDev = series(clean, dev);
exports.dev = buildDev

const browserSync = require('browser-sync').create()

function serve(cb) {
    browserSync.init({
        server: "./dist",
        port: 8000,
        host: "0.0.0.0"
    }, cb)
}

function reload(cb) {
    browserSync.reload()
    cb()
}

function watch (cb) {
    return gulp.watch(
        '**/*', // watch everything...
        {
            ignored: [
                // ...except for things generated by the build process.
                './definition/**/*',
                './dist/**/*'
            ]
        },
        // when something changes, rebuild + reload
        series(clean, dev, reload)
    )
}

const watchPipe = series(clean, dev, serve, watch)
exports.watch = watchPipe


const webpackProd = require('./webpack.prod.js')

function prod() {
    return new Promise((resolve, reject) => {
        webpack(webpackProd, (err, stats) => {
            if (err) {
                return reject(err)
            }
            if (stats.hasErrors()) {
                return reject(new Error( '\n' + stats.compilation.errors.map( e => e.message ).join('\n') ))
            }
            resolve()
        })
    })
}

function manifiest() {
    return src(['./manifiest/**/*.js']).pipe(dest('./dist/'))
}

const buildProd = series(clean, prod, manifiest);
exports.prod = buildProd

//remotePath
function upload(){
    return src(['./build/**/*'])
        .pipe(sftp({
            host: '10.96.46.160',
            user: 'seblsrv',
            pass: 'seblsrv',
            key: { location: '~/.ssh/id_rsa' },
            remotePath: '/oracle/siebel/ai_custom/scripts/siebel/custom/Scripts/StoryBoard'
        }));
}

const deploy = series(buildProd, upload)
exports.deploy = deploy